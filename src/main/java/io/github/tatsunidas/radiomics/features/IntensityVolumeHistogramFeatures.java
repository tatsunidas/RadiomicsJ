/*
 * Copyright [2022] [Tatsuaki Kobayashi]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
package io.github.tatsunidas.radiomics.features;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

import javax.swing.JOptionPane;

import org.apache.commons.math3.stat.StatUtils;

import ij.ImagePlus;
import ij.measure.Calibration;
import io.github.tatsunidas.radiomics.main.ImagePreprocessing;
import io.github.tatsunidas.radiomics.main.RadiomicsJ;
import io.github.tatsunidas.radiomics.main.Utils;

/**
 * The (cumulative) intensity-volume histogram (IVH) 
 * @author tatsunidas
 *
 */
public class IntensityVolumeHistogramFeatures{
	
	Integer label;
	ImagePlus orgMask;
	ImagePlus orgImg;
	ImagePlus dciImg;//Discretised image was generated by binWidth.
	ImagePlus cciImg;//Continuous calibrated image generated by dciImg.
	Calibration orgCal;
	boolean continuousCalibrated = false;
	
	HashMap<Double, double[]> dciIVHisto;
	HashMap<Double, double[]> cciIVHisto;

	/**
	 * 
	 * if continuousCalibrated is false, use original as discretised images (same as no descretising).
	 * 
	 * @param img
	 * @param mask
	 * @param label
	 * @param nBins
	 * @param mode: 0:No discretise (default), 1 binWidth, 2 binCount else back to defalut
	 * @throws Exception
	 */
	public IntensityVolumeHistogramFeatures(ImagePlus img, ImagePlus mask, int label, int mode) throws Exception {
		if (img == null) {
			JOptionPane.showMessageDialog(null, "RadiomicsJ: please input none null img...");
			return;
		}
		if (img.getType() == ImagePlus.COLOR_RGB) {
			JOptionPane.showMessageDialog(null, "RadiomicsJ can read only grayscale images(8/16/32 bits)...sorry.");
			return;
		}
		this.label = label;
		/*
		 * create mask
		 */
		if(mask != null) {
			if (img.getWidth() != mask.getWidth() || img.getHeight() != mask.getHeight() || img.getNSlices() != mask.getNSlices()) {
				JOptionPane.showMessageDialog(null, "RadiomicsJ: please input same dimension image and mask.");
				return;
			}
			orgMask = Utils.createMaskCopy(mask);
		}else {
			orgMask = ImagePreprocessing.createMask(img.getWidth(), img.getHeight(), img.getNSlices(), null, this.label,img.getCalibration().pixelWidth, img.getCalibration().pixelHeight,img.getCalibration().pixelDepth);
		}
		orgImg = img;
		orgCal = orgImg.getCalibration().copy();
		
		/*
		 * !IVH mode 0:No discretise (default)
		 * !IVH mode 1:Use discretise with binWidth
		 * !IVH mode 2:Use discretise with binCount
		 * !IVH mode other value : set back to defalut
		 */
		if(mode <= 0 || mode > 2) {
			this.continuousCalibrated = false;
			dciImg = orgImg;
			if(dciImg == null) {
				System.out.println("IntensityVolumeHistogramFeature calculation was failed. Please check image data.");
				return;
			}
			calculateIVHistogram4DCI(RadiomicsJ.debug);//init dciIVHisto;
		}else if(mode ==1) {
			this.continuousCalibrated = true;
			dciImg = Utils.discreteByBinWidth(orgImg, orgMask, this.label, RadiomicsJ.IVH_binWidth);
			cciImg = Utils.convertBinCenter2Intensity(orgImg, dciImg, orgMask, this.label, RadiomicsJ.IVH_binWidth);
			if(dciImg == null || cciImg == null) {
				System.out.println("IntensityVolumeHistogramFeature calculation was failed. Please check image data.");
				return;
			}
			calculateIVHistogram4CCI(false);//init cciIVHisto;
		}else if(mode ==2) {
			this.continuousCalibrated = false;
			dciImg = Utils.discrete(orgImg, orgMask, label, RadiomicsJ.IVH_binCount);
			if(dciImg == null) {
				System.out.println("IntensityVolumeHistogramFeature calculation was failed. Please check image data.");
				return;
			}
			calculateIVHistogram4DCI(RadiomicsJ.debug);//init dciIVHisto;
		}
//		if(RadiomicsJ.debug) {
//			toString();
//		}
	}
	
	public Double calculate(String id) {
		
		String name = IntensityVolumeHistogramFeatureType.findType(id);
		if (name.equals(IntensityVolumeHistogramFeatureType.VolumeAtIntensityFraction10.name())) {
			return getVolumeAtIntensityFraction(10, continuousCalibrated);
		}else if (name.equals(IntensityVolumeHistogramFeatureType.VolumeAtIntensityFraction90.name())) {
			return getVolumeAtIntensityFraction(90, continuousCalibrated);
		}else if (name.equals(IntensityVolumeHistogramFeatureType.IntensityAtVolumeFraction10.name())) {
			return getIntensityAtVolumeFraction(10, continuousCalibrated);
		}else if (name.equals(IntensityVolumeHistogramFeatureType.IntensityAtVolumeFraction90.name())) {
			return getIntensityAtVolumeFraction(90, continuousCalibrated);
		}else if (name.equals(IntensityVolumeHistogramFeatureType.VolumeFractionDifferenceBetweenIntensityFractions.name())) {
			return getVolumeFractionDifferenceBetweenIntensityFractions();
		}else if (name.equals(IntensityVolumeHistogramFeatureType.IntensityFractionDifferenceBetweenVolumeFractions.name())) {
			return getIntensityFractionDifferenceBetweenVolumeFractions();
		}else if (name.equals(IntensityVolumeHistogramFeatureType.AreaUnderTheIVHCurve.name())) {
			return getAreaUnderTheIVHCurve();
		}
		return null;
	}
	
	/**
	 * IVHistogram for Discretised calibrated image intensities
	 * 
	 * nyu is a fractional volume.
	 * gamma is a fractional intensity.
	 * 
	 * @param verbose
	 * @return
	 */
	private HashMap<Double, double[]> calculateIVHistogram4DCI(boolean verbose){
		HashMap<Double, double[]> iv_histo = new HashMap<>();
		double[] discretisedVoxels = Utils.getVoxels(dciImg, orgMask, label);
		
		double min = 0;
		double max = 0;
		
		if(RadiomicsJ.rangeMin != null && RadiomicsJ.rangeMax != null) {
			min = RadiomicsJ.rangeMin;
			max = RadiomicsJ.rangeMax;
		}else {
			double[] voxels = Utils.getVoxels(orgImg, orgMask, label);
			min = StatUtils.min(voxels);
			max = StatUtils.max(voxels);
		}
		int nv = discretisedVoxels.length;
		/*
		 * no duplicated array is usable, but when calculate Intensity at volume fraction,
		 * it result shift by 1. So, I should use continuous nBins range in for-loop.
		 */
//		double[] no_dup_values = Arrays.stream(discretisedVoxels).distinct().toArray();//keep sort pos
		for(int dv = (int)min; dv <= max; dv++) {
			int discretised_intensity = dv;
			int count = 0;
			for(double v:discretisedVoxels) {
				if(discretised_intensity > v) {
					count++;
				}
			}
			double nyu = 1-(1d/nv)*(double)count;
			double gamma = (discretised_intensity - min)/(max - min);
			iv_histo.put((double)discretised_intensity, new double[] {nyu,gamma});
		}
		
//		if(verbose) {
//			System.out.println("++++++++ IV HISTOGRAM RESULT ++++++++");
//			// converting Set to arraylist
//	        ArrayList<Double> al = new ArrayList<>(iv_histo.keySet());
//	        // sorting the list and then printing
//	        Collections.sort(al);
//	        for(Double k:al) {
//	        	System.out.println("discretise density:"+k+", nyu:"+iv_histo.get(k)[0]+", gamma:"+iv_histo.get(k)[1]);
//	        }
//			System.out.println("+++++++++++++++++++++++++++++++++++++");
//		}
		
		this.dciIVHisto = iv_histo;
		return this.dciIVHisto;
	}
	
	
	private HashMap<Double, double[]> calculateIVHistogram4CCI(boolean verbose){
		HashMap<Double, double[]> iv_histo = new HashMap<>();
		HashMap<Double, Integer> iv_count = new HashMap<>();
		
		double min = 0;
		double max = 0;
		double[] discretisedVoxels_cci = Utils.getVoxels(cciImg, orgMask, label);
		if(RadiomicsJ.rangeMin != null && RadiomicsJ.rangeMax != null) {
			min = RadiomicsJ.rangeMin;
			max = RadiomicsJ.rangeMax;
		}else {
			min = StatUtils.min(discretisedVoxels_cci);
			max = StatUtils.max(discretisedVoxels_cci);
		}
		
		int nv = discretisedVoxels_cci.length;
		double[] no_dup_values = Arrays.stream(discretisedVoxels_cci).distinct().toArray();//keep sort pos
		for (double ndp : no_dup_values) {
			if (iv_count.get(ndp) == null) {
				iv_count.put(ndp, 0);
			}
			for (double dVal : discretisedVoxels_cci) {
				if (ndp > dVal) {
					iv_count.put(ndp, iv_count.get(ndp) + 1);
				}
			}
		}
		Iterator<Double> keys = iv_count.keySet().iterator();
		while(keys.hasNext()) {
			Double k = keys.next();//key is discretised value of cci
			int count = iv_count.get(k);
			double nyu = 1-(1d/nv)*(double)count;
			double gamma = (k - min)/(max - min);
			iv_histo.put(k, new double[] {nyu,gamma});
		}
		
//		if(verbose) {
//			System.out.println("++++++++ IV HISTOGRAM CCI RESULT ++++++++");
//			// converting Set to arraylist
//	        ArrayList<Double> al = new ArrayList<>(iv_histo.keySet());
//	        // sorting the list and then printing
//	        Collections.sort(al);
//	        for(Double k:al) {
//	        	System.out.println("discrete density:"+k+", nyu:"+iv_histo.get(k)[0]+", gamma:"+iv_histo.get(k)[1]);
//	        }
//			System.out.println("+++++++++++++++++++++++++++++++++++++++++");
//		}
		this.cciIVHisto = iv_histo;
		return this.cciIVHisto;
	}
	
//	private HashMap<Double, double[]> calculateIVHistogram4CCI(boolean verbose){
//		HashMap<Double, double[]> iv_histo = new HashMap<>();
//		double[] discretisedVoxels_dci = Utils.getVoxels(dciImg, orgMask, label);
//		double[] discretisedVoxels_cci = Utils.getVoxels(cciImg, orgMask, label);
//		double min_dci = StatUtils.min(discretisedVoxels_dci);
//		double max_dci = StatUtils.max(discretisedVoxels_dci);
//		double min = StatUtils.min(discretisedVoxels_cci);
//		double max = StatUtils.max(discretisedVoxels_cci);
//		/*
//		 * see, calculateIVHistogram4DCI
//		 */
////		double[] no_dup_disc_values_dci = Arrays.stream(discretisedVoxels_dci).distinct().toArray();//keep sort pos
//		int nv = discretisedVoxels_cci.length;
//		ArrayList<Integer> done = new ArrayList<>();
//		for(int dVal = (int)min_dci; dVal <= max_dci; dVal++) {
//			int loc = 0;
//			for(int j=0;j<discretisedVoxels_dci.length;j++) {
//				if(discretisedVoxels_dci[j] == (double)dVal) {
//					loc = j;
//					break;
//				}
//			}
//			if(done.contains(Integer.valueOf(dVal))) {
//				continue;
//			}else {
//				done.add(Integer.valueOf(dVal));
//			}
//			double discretised_continuous_intensity = discretisedVoxels_cci[loc];
//			int count = 0;
//			for(double v:discretisedVoxels_cci) {
//				if(discretised_continuous_intensity > v) {
//					count++;
//				}
//			}
//			double nyu = 1-(1d/nv)*(double)count;
//			double gamma = (discretised_continuous_intensity - min)/(max - min);
//			iv_histo.put(discretised_continuous_intensity, new double[] {nyu,gamma});
//		}
//		if(verbose) {
//			System.out.println("++++++++ IV HISTOGRAM CCI RESULT ++++++++");
//			// converting Set to arraylist
//	        ArrayList<Double> al = new ArrayList<>(iv_histo.keySet());
//	        // sorting the list and then printing
//	        Collections.sort(al);
//	        for(Double k:al) {
//	        	System.out.println("discrete density:"+k+", nyu:"+iv_histo.get(k)[0]+", gamma:"+iv_histo.get(k)[1]);
//	        }
//			System.out.println("+++++++++++++++++++++++++++++++++++++++++");
//		}
//		this.cciIVHisto = iv_histo;
//		return this.cciIVHisto;
//	}
	
//	/**
//	 * IVHistogram for Discretised calibrated image intensities
//	 * @param verbose
//	 * @return
//	 */
//	private HashMap<Double, double[]> calculateIVHistogram4DCI(boolean verbose){
//		HashMap<Double, double[]> iv_histo = new HashMap<>();
//		//orgImg is already discretised.
//		double[] discretedVoxels = Utils.getVoxels(dciImg, orgMask, label);
//		double min = StatUtils.min(discretedVoxels);
//		double max = StatUtils.max(discretedVoxels);
//		int nv = discretedVoxels.length;
////		double[] no_dup_values = Arrays.stream(discretedVoxels).distinct().toArray();//keep sort pos
//		for(int i=0;i<nBins;i++) {
//			double discretised_intensity = i+1;
//			int count = 0;
//			for(double v:discretedVoxels) {
//				if(discretised_intensity > v) {
//					count++;
//				}
//			}
//			double nyu = 1-(1d/nv)*(double)count;
//			double gamma = (discretised_intensity - min)/(max - min);
//			iv_histo.put(discretised_intensity, new double[] {nyu,gamma});
//		}
//		if(verbose) {
//			System.out.println("++++++++ IV HISTOGRAM RESULT ++++++++");
//			// converting Set to arraylist
//	        ArrayList<Double> al = new ArrayList<>(iv_histo.keySet());
//	        // sorting the list and then printing
//	        Collections.sort(al);
//	        for(Double k:al) {
//	        	System.out.println("discrete density:"+k+", nyu:"+iv_histo.get(k)[0]+", gamma:"+iv_histo.get(k)[1]);
//	        }
//			System.out.println("+++++++++++++++++++++++++++++++++++++");
//		}
//		
//		this.dciIVHisto = iv_histo;
//		return this.dciIVHisto;
//	}
//	
//	private HashMap<Double, double[]> calculateIVHistogram4CCI(boolean verbose){
//		HashMap<Double, double[]> iv_histo = new HashMap<>();
//		double[] discretedVoxels_dci = Utils.getVoxels(dciImg, orgMask, label);
//		double[] discretedVoxels_cci = Utils.getVoxels(cciImg, orgMask, label);
//		double min = StatUtils.min(discretedVoxels_cci);
//		double max = StatUtils.max(discretedVoxels_cci);
//		int nv = discretedVoxels_cci.length;
//		for(int i=0;i<nBins;i++) {
//			int loc = 0;
//			for(int j=0;j<discretedVoxels_dci.length;j++) {
//				if(discretedVoxels_dci[j] == (i+1)) {
//					loc = j;
//					break;
//				}
//			}
//			double discretised_intensity = discretedVoxels_cci[loc];
//			int count = 0;
//			for(double v:discretedVoxels_cci) {
//				if(discretised_intensity > v) {
//					count++;
//				}
//			}
//			double nyu = 1-(1d/nv)*(double)count;
//			double gamma = (discretised_intensity - min)/(max - min);
//			iv_histo.put(discretised_intensity, new double[] {nyu,gamma});
//		}
//		if(verbose) {
//			System.out.println("++++++++ IV HISTOGRAM CCI RESULT ++++++++");
//			// converting Set to arraylist
//	        ArrayList<Double> al = new ArrayList<>(iv_histo.keySet());
//	        // sorting the list and then printing
//	        Collections.sort(al);
//	        for(Double k:al) {
//	        	System.out.println("discrete density:"+k+", nyu:"+iv_histo.get(k)[0]+", gamma:"+iv_histo.get(k)[1]);
//	        }
//			System.out.println("+++++++++++++++++++++++++++++++++++++++++");
//		}
//		this.cciIVHisto = iv_histo;
//		return this.cciIVHisto;
//	}
	
	private Double getVolumeAtIntensityFraction(int p_th, boolean continuousCalibrated) {
		if(!continuousCalibrated) {
			ArrayList<Double> al = new ArrayList<>(dciIVHisto.keySet());
	        Collections.sort(al);//sort for discretized order.
	        for(int i=0;i<dciIVHisto.size(); i++) {
	        	double gamma = dciIVHisto.get(al.get(i))[1];
	        	if(gamma >= p_th/100d) {
	        		return dciIVHisto.get(al.get(i))[0];//nyu
	        	}
	        }
		}else {
			ArrayList<Double> al = new ArrayList<>(cciIVHisto.keySet());
	        Collections.sort(al);//sort for discretized order.
	        for(int i=0;i<cciIVHisto.size(); i++) {
	        	double gamma = cciIVHisto.get(al.get(i))[1];
	        	if(gamma >= p_th/100d) {
	        		return cciIVHisto.get(al.get(i))[0];//nyu
	        	}
	        }
		}
		return null;
	}
	
	private Double getIntensityAtVolumeFraction(int p_th, boolean continuousCalibrated) {
		if(!continuousCalibrated) {
			ArrayList<Double> al = new ArrayList<>(dciIVHisto.keySet());
			Collections.sort(al, Collections.reverseOrder());
	        for(int i=0;i<dciIVHisto.size(); i++) {
	        	double nyu = dciIVHisto.get(al.get(i))[0];
	        	if(nyu >= p_th/100d) {
	        		return al.get(i-1);//
	        	}
	        }
		}else {
			ArrayList<Double> al = new ArrayList<>(cciIVHisto.keySet());
			Collections.sort(al, Collections.reverseOrder());
	        for(int i=0;i<cciIVHisto.size(); i++) {
	        	double nyu = cciIVHisto.get(al.get(i))[0];
	        	if(nyu >= p_th/100d) {
	        		return al.get(i-1);
	        	}
	        }
		}
		return null;
	}
	
	
	private Double getVolumeFractionDifferenceBetweenIntensityFractions() {
		Double v10 = getVolumeAtIntensityFraction(10, this.continuousCalibrated);
		Double v90 = getVolumeAtIntensityFraction(90, this.continuousCalibrated);
		if(v10 == null || v90 == null) {
			return null;
		}
		return v10-v90;
	}
	
	private Double getIntensityFractionDifferenceBetweenVolumeFractions() {
		Double v10 = getIntensityAtVolumeFraction(10, this.continuousCalibrated);
		Double v90 = getIntensityAtVolumeFraction(90, this.continuousCalibrated);
		if(v10 == null || v90 == null) {
			return null;
		}
		return v10-v90;
	}
	
	/**
	 * The area under the IVH curve can be approximated by calculating the Riemann
	 * sum using the trapezoidal rule. Note that if there is only one discretised
	 * intensity in the ROI, we define the area under the IVH curve F.ivh.auc = 0
	 * https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2701316/
	 */
	@Deprecated
	private Double getAreaUnderTheIVHCurve() {
		if (!continuousCalibrated) {
			ArrayList<Double> al = new ArrayList<>(dciIVHisto.keySet());
			Collections.sort(al);
			int size = al.size();
			double sum_nu = 0d;
			for (int i = 0; i < size; i++) {
				if (i + 1 == size) {
					break;
				}
				double d1 = al.get(i);
				double d2 = al.get(i + 1);
				double nu1 = dciIVHisto.get(al.get(i))[0];// nu:fractional volume
				double nu2 = dciIVHisto.get(al.get(i + 1))[0];
				double delta = (d2 - d1);
				sum_nu += delta/2d * (nu1 + nu2);
			}
			return sum_nu / size;
		} else {
			ArrayList<Double> al = new ArrayList<>(cciIVHisto.keySet());
			Collections.sort(al);
			int size = al.size();
			double sum_nu = 0d;
			for (int i = 0; i < size; i++) {
				if (i + 1 == size) {
					break;
				}
				double d1 = al.get(i);
				double d2 = al.get(i + 1);
				double nu1 = cciIVHisto.get(al.get(i))[0];// nu:fractional volume
				double nu2 = cciIVHisto.get(al.get(i + 1))[0];
				double delta = (d2 - d1);
				sum_nu += delta/2d * (nu1 + nu2);
			}
			return sum_nu / size;
		}
	}
	
	public String toString() {
		if(!continuousCalibrated) {
			ArrayList<Double> al = new ArrayList<>(dciIVHisto.keySet());
			Collections.sort(al);
			int size = al.size();
			System.out.println("===  IVH result (nBins)  ===");
			for(int i=0;i<size;i++) {
				double discVal = al.get(i);
				double nu = dciIVHisto.get(discVal)[0];
				double gamma = dciIVHisto.get(discVal)[1];
				System.out.println("discretised value:"+discVal+", gamma:"+gamma+", nu:"+nu);
			}
		}else {
			ArrayList<Double> al = new ArrayList<>(cciIVHisto.keySet());
			Collections.sort(al);
			int size = al.size();
			System.out.println("===  IVH result (continus, binWidth)  ===");
			for(int i=0;i<size;i++) {
				double discVal = al.get(i);
				double nu = cciIVHisto.get(discVal)[0];
				double gamma = cciIVHisto.get(discVal)[1];
				System.out.println("discretised value:"+discVal+", gamma:"+gamma+", nu:"+nu);
			}
		}
		System.out.println("=== IVH result end ===");
		return null;
	}

}
